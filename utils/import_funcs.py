from pathlib import Path
import numpy as np
import pandas as pd

def list_files_with_extension(directory, extension):
    return [str(f) for f in Path(directory).glob(f'*{extension}') if f.is_file()]

def extract_data_inline(filename):
    """
    Extract data from a text file generated by makerplot or equivalent, adapted for your column structure.
    Args:
        filename: The text file containing the data to extract.
    Returns:
        idx_start: Index of start of burn.
        idx_stop: Index of stop of burn.
        delta_time: Median time difference between records.
        T : DataFrame of temperatures.
        X : DataFrame of voltages and other signals.
    """
    data = pd.read_table(filename, delimiter=',')
    
    # Identify start and stop indices for the burn using 'power_flag'
    idx_start = np.where(np.diff(np.insert(data['power_flag'].values, 0, 0)) == 1)[0].tolist()
    idx_stop = np.where(np.diff(np.append(data['power_flag'].values, 0)) == -1)[0].tolist()
    
    # Extract voltages and other signals
    V_rad_short = data['V_radshort'].to_numpy()
    V_rad_tot = data['V_radtotal'].to_numpy()
    V_housing = data['V_housing'].to_numpy()
    V_diode = data['V_diode'].to_numpy()
    V_spike = data['VTC2'].to_numpy()
 
    
    # Cooling flags
    cooling_flag_1 = data['antenna_cooling_flag'].to_numpy() if 'antenna_cooling_flag' in data.columns else [float('nan')] * len(data)
    cooling_flag_2 = data['switch_cooling_flag'].to_numpy() if 'switch_cooling_flag' in data.columns else [float('nan')] * len(data)
    # print(data.Time)
    power = data['Power'].to_numpy() * (data['power_flag'] > 0).astype(float)

    delta_time = np.median(np.diff(data['Time'].astype(float).values))
    
    # Temperatures (using VTC2 as T_housing, V_diode as T_diode, V_probe as T_display)
    T = pd.DataFrame({
        'T_antenna': [float('nan')] * len(data),  # Not available in your columns
        'T_diode': V_diode,
        'T_housing': data['VTC2'].to_numpy(),
        'T_display': data['V_probe'].to_numpy()
    })
    
    X = pd.DataFrame({
        'V_rad_short': V_rad_short,
        'V_rad_tot': V_rad_tot,
        'V_housing': V_housing,
        'V_diode': V_diode,
        'V_spike': V_spike,
        'cooling_flag_1': cooling_flag_1,
        'cooling_flag_2': cooling_flag_2,
        'power': power
    })
    
    return idx_start, idx_stop, delta_time, T, X


def my_kalman_filter(signal, Qb=10):
    """
    Return the signal filtered with a Kalman filter with inertia Qb.
    All the other parameters are set for the analysis of the radiometric signal and shouldn't be changed.

    Parameters:
    signal : list or numpy array of float values corresponding to the radiometric Temperatures (Â°C)
    Qb (optional, default=10) : the parameter describing the inertia of the Kalman model, do not put under 1

    Returns:
    signal_kalman: The signal processed by the kalman filter (numpy array)
    """
    # Set the inertia
    if Qb is None:
        Qb = 10

    # Initializing the system for the kalman filter
    P0 = 0.2179  # put only one seed to make testing more reproducible
    G0 = 0.9421
    # P0 = np.random.rand(1, 1)
    # G0 = np.random.rand(1, 1)
    A = 1
    C = 1
    Qv = 1

    if len(signal) == 0:
        signal_kalman = np.array([])
    else:
        init = signal[0]
        signal_kalman = train_kalman(signal, A, C, G0, P0, Qv, Qb, init)

    return signal_kalman

def train_kalman(y, A, C, G0, P0, Qv, Qb, z0):
    z = np.zeros(len(y))
    z[0] = z0
    P = P0
    G = G0
    for i in range(len(y)-1):
        x = y[i]
        z_i = z[i]
        z_next = my_predict(z_i, A, x, C, G)
        z[i+1] = z_next
        G, P = update_filter(G, P, A, Qv, Qb, C)
    return z

def update_filter(G, P, A, Qv, Qb, C):
    P_next = A * (1 - G * C) * P * A + Qv
    G_next = P_next * C / (C * P * C + Qb)
    return G_next, P_next

def my_predict(z, A, x, C, G):
    """
    Prediction step of the Kalman filter.
    """
    e = x - C * z
    z_next = A * z + A * G * e
    return z_next